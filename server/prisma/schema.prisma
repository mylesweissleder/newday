// Network CRM Database Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id          String   @id @default(cuid())
  name        String
  email       String   @unique
  password    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  isActive    Boolean  @default(true)
  
  // Join code system for crew members
  joinCode    String?  @unique
  joinCodeEnabled Boolean @default(false)
  
  // Relations
  users       User[]
  contacts    Contact[]
  campaigns   Campaign[]
  opportunities OpportunitySuggestion[]
  networkGaps NetworkGap[]
  skillRecommendations SkillRecommendation[]
  
  @@map("accounts")
}

model User {
  id              String   @id @default(cuid())
  email           String   @unique
  password        String?
  firstName       String
  lastName        String
  profilePic      String?
  bio             String?
  phone           String?
  timezone        String?
  role            UserRole @default(MEMBER)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  isActive        Boolean  @default(true)
  
  // Invitation system
  invitationToken String?  @unique
  invitedAt       DateTime?
  invitedBy       String?
  acceptedAt      DateTime?
  
  // Password reset system
  resetToken      String?  @unique
  resetTokenExpiry DateTime?
  
  // Activity tracking
  lastLoginAt     DateTime?
  loginCount      Int      @default(0)
  
  // Relations
  account   Account @relation(fields: [accountId], references: [id])
  accountId String
  
  // Activity tracking
  contactsCreated Contact[] @relation("CreatedBy")
  contactsUpdated Contact[] @relation("UpdatedBy")
  outreachSent    Outreach[]
  campaignsCreated Campaign[] @relation("CampaignCreatedBy")
  contactContributions ContactContribution[] @relation("ContactContributions")
  
  // Skills system
  skills               UserSkill[] @relation("UserSkills")
  skillRequests        SkillRecommendation[] @relation("SkillRequests")
  skillProvisions      SkillRecommendation[] @relation("SkillProvisions")
  
  @@map("users")
}

model Contact {
  id          String   @id @default(cuid())
  firstName   String
  lastName    String
  email       String?
  phone       String?
  company     String?
  position    String?
  linkedinUrl String?
  twitterUrl  String?
  website     String?
  
  // Categorization
  tier        ContactTier?
  tags        String[]
  source      String?
  status      ContactStatus @default(ACTIVE)
  
  // Crew-wide sharing
  isSharedWithCrew Boolean @default(false)
  originalOwnerId  String? // Who first added this contact
  contributorIds   String[] // All crew members who contributed data
  
  // AI Insights and Scoring
  aiInsights          Json?
  personalityScore    Float?
  engagementScore     Float?
  priorityScore       Float?        // Overall AI priority score (0-100)
  opportunityScore    Float?        // Opportunity likelihood score (0-100)
  strategicValue      Float?        // Strategic networking value (0-100)
  scoringFactors      Json?         // Detailed breakdown of scoring factors
  lastScoringUpdate   DateTime?     // When scores were last calculated
  opportunityFlags    String[]      // AI-detected opportunity indicators
  
  // Relationship tracking
  connectionDate    DateTime?
  lastContactDate   DateTime?
  relationshipType  RelationshipType?
  relationshipNotes String?
  
  // Location
  city     String?
  state    String?
  country  String?
  timezone String?
  
  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  account   Account @relation(fields: [accountId], references: [id])
  accountId String
  
  createdBy   User   @relation("CreatedBy", fields: [createdById], references: [id])
  createdById String
  
  updatedBy   User?   @relation("UpdatedBy", fields: [updatedById], references: [id])
  updatedById String?
  
  // Many-to-many relationships
  relationships ContactRelationship[] @relation("Contact")
  relatedTo     ContactRelationship[] @relation("RelatedContact")
  
  // Potential relationships
  potentialRelationships PotentialRelationship[] @relation("PotentialContact")
  potentialRelatedTo     PotentialRelationship[] @relation("PotentialRelatedContact")
  
  // Network analytics
  networkAnalytics NetworkAnalytics?
  
  // Outreach history
  outreach Outreach[]
  
  // Campaign associations
  campaignContacts CampaignContact[]
  
  // Opportunity associations
  primaryOpportunities   OpportunitySuggestion[] @relation("PrimaryOpportunityContact")
  secondaryOpportunities OpportunitySuggestion[] @relation("SecondaryOpportunityContact")
  opportunityContacts    OpportunityContact[]
  
  // Crew sharing system
  contributions          ContactContribution[]
  mutualRecommendations  SkillRecommendation[] @relation("RecommendationMutualContacts")
  
  @@unique([email, accountId])
  @@map("contacts")
}

model ContactRelationship {
  id String @id @default(cuid())
  
  contact         Contact @relation("Contact", fields: [contactId], references: [id], onDelete: Cascade)
  contactId       String
  
  relatedContact  Contact @relation("RelatedContact", fields: [relatedContactId], references: [id], onDelete: Cascade)
  relatedContactId String
  
  relationshipType RelationshipType
  strength         Float? @default(0.5) // 0-1 scale
  confidence      Float? @default(0.5) // How confident we are in this relationship (0-1)
  notes           String?
  source          String? // How was this relationship discovered (manual, linkedin, email_domain, etc.)
  
  // Relationship metadata
  discoveredAt    DateTime @default(now())
  discoveredBy    String? // User ID who discovered/created this relationship
  lastVerified    DateTime?
  isVerified      Boolean @default(false)
  isMutual        Boolean @default(false) // Is this a bidirectional relationship?
  
  // Network analysis fields
  interactionCount Int @default(0) // Number of times they've interacted
  sharedConnections Int @default(0) // Number of mutual connections
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([contactId, relatedContactId])
  @@index([relationshipType])
  @@index([strength])
  @@index([source])
  @@index([discoveredAt])
  @@index([isVerified])
  @@index([isMutual])
  @@map("contact_relationships")
}

// Track potential relationships that haven't been verified yet
model PotentialRelationship {
  id String @id @default(cuid())
  
  contact         Contact @relation("PotentialContact", fields: [contactId], references: [id], onDelete: Cascade)
  contactId       String
  
  relatedContact  Contact @relation("PotentialRelatedContact", fields: [relatedContactId], references: [id], onDelete: Cascade)
  relatedContactId String
  
  relationshipType RelationshipType
  confidence      Float // How confident we are (0-1)
  evidence        Json // Evidence for this potential relationship
  source          String // How was this discovered
  
  // Status tracking
  status          PotentialRelationshipStatus @default(PENDING)
  reviewedBy      String? // User ID who reviewed
  reviewedAt      DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([contactId, relatedContactId])
  @@index([confidence])
  @@index([source])
  @@index([status])
  @@map("potential_relationships")
}

// Network analysis cache for performance
model NetworkAnalytics {
  id String @id @default(cuid())
  
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  contactId String @unique
  
  // Network metrics
  totalConnections    Int @default(0)
  directConnections   Int @default(0)
  mutualConnections   Int @default(0)
  networkReach        Int @default(0) // 2nd degree connections
  influenceScore      Float @default(0) // Based on network position
  
  // Connection diversity
  industryDiversity   Float @default(0) // How diverse their connections are
  geographicSpread    Float @default(0)
  senioritySpread     Float @default(0)
  
  // Key connector metrics
  betweennessCentrality Float @default(0) // How often they bridge different groups
  clusteringCoefficient Float @default(0) // How connected their connections are
  
  // Last calculation
  lastCalculated DateTime @default(now())
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("network_analytics")
}

// Track individual contributions to shared contacts
model ContactContribution {
  id String @id @default(cuid())
  
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  contactId String
  
  contributor   User @relation("ContactContributions", fields: [contributorId], references: [id])
  contributorId String
  
  // What data was contributed
  fieldsContributed String[] // e.g., ["email", "phone", "company"]
  sourceInfo        String?  // Original source of this data
  importSource      String?  // How it was imported (CSV, LinkedIn, etc.)
  confidence        Float @default(1.0) // Confidence in this data
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([contactId, contributorId])
  @@map("contact_contributions")
}

model Campaign {
  id          String   @id @default(cuid())
  name        String
  description String?
  objective   String?
  status      CampaignStatus @default(DRAFT)
  
  // Campaign settings
  startDate   DateTime?
  endDate     DateTime?
  isActive    Boolean @default(true)
  
  // Templates
  emailTemplate    String?
  linkedinTemplate String?
  emailSubject     String?
  
  // Performance tracking
  totalSent       Int @default(0)
  totalOpened     Int @default(0)
  totalResponded  Int @default(0)
  
  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  account   Account @relation(fields: [accountId], references: [id])
  accountId String
  
  createdBy   User?   @relation("CampaignCreatedBy", fields: [createdById], references: [id])
  createdById String?
  
  contacts       CampaignContact[]
  emailTemplates CampaignEmailTemplate[]
  
  @@map("campaigns")
}

model CampaignContact {
  id String @id @default(cuid())
  
  campaign   Campaign @relation(fields: [campaignId], references: [id])
  campaignId String
  
  contact   Contact @relation(fields: [contactId], references: [id])
  contactId String
  
  status           CampaignContactStatus @default(PENDING)
  personalizedNote String?
  lastContacted    DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([campaignId, contactId])
  @@map("campaign_contacts")
}

model CampaignEmailTemplate {
  id String @id @default(cuid())
  
  name        String
  subject     String
  bodyText    String
  bodyHtml    String?
  isDefault   Boolean @default(false)
  
  // Template variables/placeholders
  variables   String[] @default([])
  
  campaign   Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  campaignId String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("campaign_email_templates")
}

model Outreach {
  id      String @id @default(cuid())
  type    OutreachType
  status  OutreachStatus @default(PENDING)
  subject String?
  message String
  
  // Response tracking
  sentAt      DateTime?
  openedAt    DateTime?
  respondedAt DateTime?
  response    String?
  
  // Relations
  contact   Contact @relation(fields: [contactId], references: [id])
  contactId String
  
  sentBy   User   @relation(fields: [sentById], references: [id])
  sentById String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("outreach")
}

// Enums
enum UserRole {
  CREW_LEADER
  ADMIN
  MEMBER
  VIEWER
}

enum ContactTier {
  TIER_1
  TIER_2
  TIER_3
  TIER_4
}

enum ContactStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
  BLOCKED
}

enum RelationshipType {
  COLLEAGUE
  CLIENT
  VENDOR
  PARTNER
  INVESTOR
  MENTOR
  MENTEE
  FRIEND
  FAMILY
  ACQUAINTANCE
  PROSPECT
  COMPETITOR
}

enum CampaignStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
  ARCHIVED
}

enum CampaignContactStatus {
  PENDING
  CONTACTED
  RESPONDED
  INTERESTED
  NOT_INTERESTED
  CONVERTED
  BOUNCED
}

enum OutreachType {
  EMAIL
  LINKEDIN
  PHONE
  MEETING
  OTHER
}

enum OutreachStatus {
  PENDING
  SENT
  DELIVERED
  OPENED
  RESPONDED
  FAILED
}

enum PotentialRelationshipStatus {
  PENDING
  APPROVED
  REJECTED
  AUTO_APPROVED
}

// Opportunity suggestions and recommendations
model OpportunitySuggestion {
  id String @id @default(cuid())
  
  // Basic info
  title       String
  description String
  category    OpportunityCategory
  type        OpportunityType
  priority    OpportunityPriority @default(MEDIUM)
  
  // Confidence and scoring
  confidenceScore   Float    // 0-1 confidence in this suggestion
  impactScore       Float    // 0-100 potential impact score
  effortScore       Float    // 0-100 estimated effort required
  
  // Status tracking
  status        OpportunityStatus @default(PENDING)
  statusReason  String?
  
  // Timing and context
  suggestedAt   DateTime @default(now())
  bestTiming    DateTime? // When this opportunity should be acted upon
  expiresAt     DateTime? // When this opportunity expires
  
  // AI reasoning and data
  aiReasoning   Json      // Detailed AI explanation
  evidence      Json      // Supporting evidence and data
  metadata      Json?     // Additional context data
  
  // Relations
  account       Account @relation(fields: [accountId], references: [id])
  accountId     String
  
  primaryContact    Contact? @relation("PrimaryOpportunityContact", fields: [primaryContactId], references: [id])
  primaryContactId  String?
  
  secondaryContact    Contact? @relation("SecondaryOpportunityContact", fields: [secondaryContactId], references: [id])
  secondaryContactId  String?
  
  relatedContacts     OpportunityContact[]
  actions            OpportunityAction[]
  
  // User interaction tracking
  viewedBy      String? // User ID who viewed this
  viewedAt      DateTime?
  actedBy       String? // User ID who acted on this
  actedAt       DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("opportunity_suggestions")
}

// Junction table for opportunities involving multiple contacts
model OpportunityContact {
  id String @id @default(cuid())
  
  opportunity     OpportunitySuggestion @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  opportunityId   String
  
  contact         Contact @relation(fields: [contactId], references: [id])
  contactId       String
  
  role            OpportunityContactRole // How this contact relates to the opportunity
  importance      Float @default(0.5)    // 0-1 importance in this opportunity
  
  createdAt DateTime @default(now())
  
  @@unique([opportunityId, contactId])
  @@map("opportunity_contacts")
}

// Track actions taken on opportunities
model OpportunityAction {
  id String @id @default(cuid())
  
  opportunity     OpportunitySuggestion @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  opportunityId   String
  
  actionType      OpportunityActionType
  actionData      Json? // Action-specific data
  result          OpportunityActionResult?
  resultData      Json? // Result-specific data
  
  notes           String?
  
  takenBy         String // User ID
  takenAt         DateTime @default(now())
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("opportunity_actions")
}

// Network gap analysis results
model NetworkGap {
  id String @id @default(cuid())
  
  account       Account @relation(fields: [accountId], references: [id])
  accountId     String
  
  gapType       NetworkGapType
  title         String
  description   String
  importance    Float @default(0.5) // 0-1 importance score
  
  // Gap details
  targetIndustry     String?
  targetRole         String?
  targetCompanySize  String?
  targetLocation     String?
  
  // Current network analysis
  currentCoverage    Float @default(0) // 0-1 how well this gap is currently covered
  potentialContacts  Json? // Suggested contacts to fill this gap
  
  // Metadata
  analysisData       Json  // Detailed analysis results
  suggestions        Json? // Specific suggestions to fill this gap
  
  // Status
  status            NetworkGapStatus @default(ACTIVE)
  addressedAt       DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("network_gaps")
}

// Enums for opportunity system
enum OpportunityCategory {
  INTRODUCTION
  RECONNECTION
  BUSINESS_MATCH
  NETWORK_EXPANSION
  STRATEGIC_MOVE
  EVENT_DRIVEN
  FOLLOW_UP
}

enum OpportunityType {
  WARM_INTRODUCTION
  COLD_OUTREACH
  RECONNECT
  BUSINESS_PROPOSAL
  PARTNERSHIP
  CLIENT_REFERRAL
  JOB_OPPORTUNITY
  INVESTMENT_OPPORTUNITY
  KNOWLEDGE_EXCHANGE
  EVENT_INVITATION
}

enum OpportunityPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum OpportunityStatus {
  PENDING
  VIEWED
  ACCEPTED
  DISMISSED
  IN_PROGRESS
  COMPLETED
  EXPIRED
  FAILED
}

enum OpportunityContactRole {
  PRIMARY_TARGET
  INTRODUCER
  MUTUAL_CONNECTION
  DECISION_MAKER
  INFLUENCER
  BENEFICIARY
}

enum OpportunityActionType {
  VIEW
  ACCEPT
  DISMISS
  SEND_INTRODUCTION_REQUEST
  SEND_EMAIL
  SCHEDULE_MEETING
  MAKE_CALL
  SEND_LINKEDIN_MESSAGE
  CREATE_REMINDER
  MARK_COMPLETE
  PROVIDE_FEEDBACK
}

enum OpportunityActionResult {
  SUCCESS
  FAILED
  PARTIAL
  NO_RESPONSE
  DECLINED
  POSTPONED
}

enum NetworkGapType {
  INDUSTRY_GAP
  ROLE_GAP
  SENIORITY_GAP
  GEOGRAPHIC_GAP
  FUNCTIONAL_GAP
  COMPANY_SIZE_GAP
  DIVERSITY_GAP
}

enum NetworkGapStatus {
  ACTIVE
  ADDRESSING
  ADDRESSED
  DISMISSED
}

// Skills and offerings system for crew members
model UserSkill {
  id String @id @default(cuid())
  
  user   User @relation("UserSkills", fields: [userId], references: [id])
  userId String
  
  skill   Skill @relation(fields: [skillId], references: [id])
  skillId String
  
  type        SkillType // ASK (need) or HAVE (offer)
  proficiency SkillLevel? // Only for HAVE skills
  isActive    Boolean @default(true)
  notes       String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([userId, skillId, type])
  @@map("user_skills")
}

model Skill {
  id String @id @default(cuid())
  
  name        String @unique
  category    String?
  description String?
  tags        String[]
  
  // Relations
  userSkills    UserSkill[]
  recommendations SkillRecommendation[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("skills")
}

// AI-generated recommendations based on skills matching
model SkillRecommendation {
  id String @id @default(cuid())
  
  account   Account @relation(fields: [accountId], references: [id])
  accountId String
  
  // Who is asking/needing
  requester   User @relation("SkillRequests", fields: [requesterId], references: [id])
  requesterId String
  
  // What skill they need
  skill   Skill @relation(fields: [skillId], references: [id])
  skillId String
  
  // Who can provide it
  provider   User? @relation("SkillProvisions", fields: [providerId], references: [id])
  providerId String?
  
  // How they're connected
  connectionPath Json? // AI-generated relationship path
  mutualContacts Contact[] @relation("RecommendationMutualContacts")
  
  // AI reasoning
  matchScore     Float    // 0-100 how good this match is
  aiReasoning    Json     // Detailed explanation
  icebreaker     String?  // AI-generated introduction
  
  // Status tracking
  status         RecommendationStatus @default(PENDING)
  viewedBy       String?
  viewedAt       DateTime?
  actedBy        String?
  actedAt        DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("skill_recommendations")
}

// Enums for skills system
enum SkillType {
  ASK  // What they need/want
  HAVE // What they can offer/provide
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum RecommendationStatus {
  PENDING
  VIEWED
  CONTACTED
  CONNECTED
  DISMISSED
  EXPIRED
}